#!/bin/bash
# Push to host

. /srv/dcp/bin/dcp_common

usage()
{
    cat <<EOF
    usage: $1 [-a] [-n] [-f] (-h <hosts_list> | <host>) [<files>]
       Push files tracked by dcp to host
       -a  Push all files in the tree
       -f  Push even if there are uncommitted changes
       -n  dry-run
       -h  <hosts_list> is a file containing list of hosts to push to
EOF
    return 0
}

n_args=2
while getopts ":afnh:" opt; do
    case $opt in
	a ) all=1
	    n_args=1
	f ) force=1;;
	n ) dry=--dry-run;;
	h ) host_list=$OPTARG
	\? ) usage
            exit 1;;
	: ) echo "Option -$OPTARG requires an argument." >&2
	    usage
	    exit 1;;
	* ) usage
            exit 1;;
    esac
done
shift $(($OPTIND - 1))

if [ $# -lt $n_args ]; then
        usage $(basename $0)
        exit 1
fi

push_ () {
    host=$1
    shift

    if ! ping -c1 $host >/dev/null 2>&1 ; then
	echo $host not available
	return
    fi

    cd ${HOST_STORE}/$host
    if [[ -n "$(git status --porcelain 2>&1)" ]]; then
	echo Some changes not comitted for $host
	git status --porcelain
	[[ -z "$force" ]] && return
	echo "forcing push as requested"
    fi
	
    # zero the filelist
    > ../${host}.files
    # Now: either push all or just specified files
    if [[ -n "$all" ]] ; then
	find . -name .git -prune -o -type f -print >> ../${host}.files
    else
	for f in "$@"; do
	    echo $f >> ../${host}.files
	done
    fi

    # push
    rsync -a $dry --files-from=../${host}.files . root@$host:/
    rm -f ../${host}.files
}

if [[ -n $host_list ]]; then
    while read -u 8 host; do
	push_ $host "$@"
    done 8< $host_list
else
    push_ "$@"
fi
